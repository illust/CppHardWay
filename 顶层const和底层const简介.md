## 顶层 const 与底层 const 概念
***第一***，指针本身是一个对象，因为，指针实际对应着内存单元的一段存储空间，然而，指针所指向的也是一个数据对象，
因此，指针是一个常量与指针所指向的是一个常量是两个完全不同的概念，
顶层 const 表示的是指针本身是一个常量， 底层const 表示的是指针所指的对象是一个常量，
更一般情况下， 顶层const可以表示任意对象是一个常量，这对于算术类型、类、指针等任何数据类型都是成立的，
底层 const 则与指针和引用等复合类型的基本类型部分有关，
比较特殊的是，指针既可以是顶层 const 也可以是底层 const，这一点与其他类型区别明显。

***第二***，对于顶层 const 与底层 const ，在执行对象拷贝时有着明显的不同。
顶层 const 不受什么影响：
```
int i = 0;  
const int ci = 42;       // 不能改变 ci 的值，这是一个顶层 const  
i = ci;                        // 正确：ci 是一个顶层 const，对此操作无影响  
const int *p2 = &ci;  // 允许改变 p2 的值，这是一个底层 const  
const int *const p3 = p2;  // 靠右的 const 是顶层 const ，靠左的是底层 const  
p2 = p3;                  // 正确：p2 和 p3 指向的对象的类型相同，p3 顶层 const 的部分不影响 
```
底层const的限制不能忽略。要求拷出和拷入的对象有相同的底层 const 资格或者能转换为相同的数据类型，一般非常量能够向常量转换，反之则不行：
```
int *p = p3;           // 错误：p3 包括底层 const 定义，而 p 没有  
p2 = p3;                // 正确：p2 和 p3 都是底层 const  
p2 = &i;                 // 正确：int* 能转换成 const int*  
int &r = ci;  // 错误：普通的 int& 不能绑定到 int 常量上  
const int &r2 = i;   // 正确：const int& 可以绑定到一个普通 int 上  
```


